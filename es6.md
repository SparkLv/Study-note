# ES6
### Babel转换器  
配置文件为.babelrc，使用babel工具和模块需要先写好这个配置文件  
#### babel-cli工具  
##### 转码结果写入一个文件  

    $ babel a.js --out-file b.js
    或
    $ babel a.js -o b.js
##### 整个目录转码  

    $ babel src --out-dir lib
    或
    $ babel src -d lib
##### 需要将babel-cli安装在项目之中  

    $ npm install --save-dev babel-cli
    package-json
    'devDependencies':{
        "babel-cli":'xxxx'
    }
    "script":{
        "build":"babel src -d lib"
    }
    最后
    $ npm run build  
## let和const命令  
### let  
let声明的变量只在let命令所在的代码块内有效  
在for循环中，当前let的索引仅在本轮循环有效，所以每一次循环的索引都是一个新的变量  
#### let不存在变量提升  
var命令的变量提升，变量可以在声明之前使用，值为undefined  
let声明的变量一定要在声明之后使用，否则会报错。ES6明确规定，如果区块中存在let和const命令，在声明之前就使用这些变量，就会报错  
#### let不允许在相同作用域内，重复声明同一变量  
ES6允许块级作用域的任意嵌套，内层作用域可以定义外层作用域的同名变量  
### const  
声明一个只读的常量，一旦声明，常量的值就不能改变,而且必须立即初始化，和let相同，只在声明所在的块级作用域内有效  
如果const声明的是一个数组或者对象，那么可以进行添加属性等操作。但不可以赋值  
## 变量的解构赋值  
ES6允许 let [a,b,c] = [1,2,3];  
如果左右不对应，解构会失败，但是会部分成功，称作不完全解构  
### 解构赋值允许指定默认值  

    let[foo = true] = []
    let [x = 1] = [undefined]
    let [x = 1] = [null]  
ES6采用严格的相等运算符"===",如果一个数组成员不严格等于undefined，默认值不会生效  
如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候才会求值
### 对象解构赋值  
对象的解构赋值和数组不同，数组是按次序排列，由位置决定。而对象必须与属性同名才能取值  
### 字符串解构赋值  
const [a,b,c,d,e] = 'hello';  
## 字符串扩展  
ES6为字符串提供了遍历接口，使得字符串可以被for...of循环遍历  
### includes(),startsWith(),endsWith()
作用分别是，是否找到了参数字符串，参数字符串是否在原字符串的头部，参数字符串是否在原字符串的尾部。  
这些方法都支持第二个参数，表示搜索位置，但是endsWith表示的是针对前n个字符  
### repeat  
返回一个新字符串，表示将原字符串重复n次  
## 函数的扩展  
ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。要注意的是，参数变量是默认声明的，所以不能用let和const再次声明。另外，函数不能有同名参数  
### length属性  
将返回函数没有指定默认值的参数个数


